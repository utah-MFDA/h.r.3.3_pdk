
`include "disciplines.vams"
`include "constants.vams"

module diffmix_25px_0(fl_i1, fl_i2, fl_out, c_i1, c_i2, c_out);

inout fl_i1, fl_i2, fl_out;
inout c_i1, c_i2, c_out;

electrical fl_i1, fl_i2, fl_out;
electrical c_i1, c_i2, c_out;

//internal nodes
electrical int_1;
//electrical ic1, ic2;
//electrical c_in1, c_in2;

(*desc="cross-section", type="instance"*)  parameter real CROSS_SECTION=1;
(*desc="viscosity", type="instance"*) parameter real NU = 0.001006;

real LENGTH1;
real LENGTH2;
real LENGTH3;

real R1_3;
real R2_3; 
real R1, R2, R3;
real W, H, L1, L2, L3;
real ch_height_layers, ch_width_pixels;

real pixel_width;// = 7.6u;
real layer_height;// = 10u;

ground gnd;

//branch(c_i1, c_out) chem1;
//branch(c_i2, c_out) chem2;

//real Vc1;//, Vc2;

analog begin

   @(initial_instance) 
   begin : initial_instance
      
   pixel_width = 7.6u;
   layer_height = 10u;

   LENGTH1=0.19m;
   LENGTH2=0.269m;
   LENGTH3=0.190m;

   begin
   if  (CROSS_SECTION == 1) begin
      ch_height_layers = 10;
      ch_width_pixels  = 14;
   end
   else if(CROSS_SECTION== 2) begin
      ch_height_layers = 5;
      ch_width_pixels  = 6;
   end
   end

   W  = ch_width_pixels * pixel_width;
   H  = ch_height_layers* layer_height;
   L1 = LENGTH1;
   L2 = LENGTH2;
   L3 = LENGTH3;

   R1 = (12*NU*L1) / (1 - 0.63*(H/W)) * 1/(H*H*H*W);
   R2 = (12*NU*L2) / (1 - 0.63*(H/W)) * 1/(H*H*H*W);
   R3 = (12*NU*L3) / (1 - 0.63*(H/W)) * 1/(H*H*H*W);

   R1_3 = R1 + R3;
   R2_3 = R2 + R3;

   $display("resistance Mixer:");
   $display(R1);
   $display(R2);
   $display(R3);
   $display("test 4");

   //Vc1 = V(int_1, gnd);
   //Vc2 = V(fl_i1, gnd);

   //$display(Vc1);
   //$display(Vc2);
   //$display(" ");
   //$display(R1_3);
   //$display(R2_3);
   end // end initial_step

   //fl_c1 = (V(fl_i1, fl_out)/R1_3) / (V(fl_i1, fl_out)/R1_3 + V(fl_i2, fl_out)/R2_3);
   //fl_c2 = (V(fl_i2, fl_out)/R2_3) / (V(fl_i1, fl_out)/R1_3 + V(fl_i2, fl_out)/R2_3);

   I(fl_i1, int_1) <+ V(fl_i1, int_1)/R1;
   I(fl_i2, int_1) <+ V(fl_i2, int_1)/R2;

   I(int_1, fl_out) <+ V(int_1, fl_out)/R3;

   //Concentration signals
   //V(ic1) <+ V(c_i1, gnd) * (V(fl_i1, int_1)/R1) / (V(int_1, fl_out)/R3);
   //V(ic2) <+ V(c_i2, gnd) * ((V(fl_i2, int_1)/R2) / (V(int_1, fl_out)/R3));
   //V(c_in1, gnd) <+ V(c_i1, gnd) * (V(fl_i1, fl_out)/R1_3) / (V(fl_i1, fl_out)/R1_3 + V(fl_i2, fl_out)/R2_3);
   //V(c_in2, gnd) <+ V(c_i2, gnd) * (V(fl_i2, fl_out)/R2_3) / (V(fl_i1, fl_out)/R1_3 + V(fl_i2, fl_out)/R2_3);
   //V(c_out) <+ V(ic1) + V(ic2);

   if (V(int_1, fl_out) > 0) 
      V(c_out, gnd) <+ V(c_i1, gnd) * (V(fl_i1, int_1)/R1) / (V(int_1, fl_out)/R3);
   //else 
   //   V(c_out, gnd) <+ V(c_i1, gnd);
      //V(c_i1) * ((V(fl_i1, int_1)/R1) / (V(int_1, fl_out)/R3));

   if (V(int_1, fl_out) > 0) 
      V(c_out, gnd) <+ V(c_i2, gnd) * ((V(fl_i2, int_1)/R2) / (V(int_1, fl_out)/R3));
   //else 
   //   V(c_out, gnd) <+ 0;//V(c_i2, gnd);
      //V(c_i2);// * ((V(fl_i2, int_1)/R2) / (V(int_1, fl_out)/R3));


   //I(chem1) <+ 0;
   //I(chem2) <+ 0;
   //V(c_out, gnd) <+ V(c_in1, gnd) + V(c_in2, gnd);
   //V(c_out, gnd) <+ V(c_i1, gnd)*fl_c1 + V(c_i1, gnd)*fl_c2; 
end

endmodule
